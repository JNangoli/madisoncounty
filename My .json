{
  "title": "Testining Henry County Iowa",
  "excerpt": "Jude Test",
  "content": "tl;dr\n\n    React Router has preview support for RSC!\n        Clone this repo to try it out\n    RSC content from loaders/actions in existing routes\n    RSC-first \"Server Component Routes\"\n    Client components with \"use client\"\n    Server Functions with \"use server\"\n    Check out the demo\n        Live Demo\n        Source Code\n    Middleware for batching and caching queries\n    Stable release blocked by RSC support in Vite\n        The preview uses Parcel\n        Alternative Bundler integration will be easier than ever\n\nAcknowledgement\n\nBefore we dig in, I just need to take a moment to acknowledge the work of Jacob Ebey. He has been working on RSC support for Remix and React Router for ... years.\n\nHe has probably built 12 versions of this. He figured out the best way to support all of React's API in a way that is incrementally adoptable by the millions of React Router apps in production today, but also feels great for a greenfield React Router app.\n\nWhile the project is the work of our whole team and community, RSC in React Router absolutely would not have happened without Jacob. Thank you!\nTry it out\n\ngit clone https://github.com/jacob-ebey/experimental-parcel-react-router-starter\n\nThen follow the instructions in the README.md.\nWhat it looks like\nRSC From Loaders\n\nAs shown at React conf you can render elements in your loaders and actions in existing Route Loaders. This allows you to use RSC only where you want it and facilitates incremental adoption.\n\nA really compelling use case for RSC is when your data determines your components. Without RSC every component needs to be bundled and sent to the browser. With RSC only the rendered client components go to the browser.\n\nexport async function loader({ params }) {\n  let { contentBlocks, ...product } = await getProduct(params.productId);\n  return {\n    product,\n    content: (\n      <div>\n        {contentBlocks.map((block) => {\n          switch (block.type) {\n            case \"image\":\n              return <ImageBlock {...block} />;\n            case \"gallery\":\n              return <GalleryBlock {...block} />;\n            case \"video\":\n              return <VideoBlock {...block} />;\n            case \"text\":\n              return <TextBlock {...block} />;\n            case \"markdown\":\n              return <MarkdownBlock {...block} />;\n            default:\n              throw new Error(`Unknown block type: ${block.type}`);\n          }\n        })}\n      </div>\n    ),\n  };\n}\n\nexport default function Article({ loaderData }) {\n  return (\n    <ProductLayout product={loaderData.product}>\n      {loaderData.content}\n    </ProductLayout>\n  );\n}\n\nThis use case is particularly evident when backing your site with a CMS, Shopify, or any kind of activity feed on dashboards and social media.\n\nBy returning RSC content from loaders, you can get this benefit without going \"all in\" on server components everywhere else.\nServer Component Routes\n\nCurrent Route modules can be thought of as \"client component routes\". They are bundled and sent to the browser, allowing you to useState right inside of a route component.\n\nReturning RSC content from loaders sent to a client component route isn't the full architecture that React is going for with RSC. In support of that vision, you can also create RSC-first \"Server Component Routes\".\n\nOr SCRs, not be confused with RSCs, or even CSR, oh boy ...\n\nServer Routes (that's better) are defined by exporting a ServerComponent instead of default:\n\nexport async function ServerComponent({ params }) {\n  let project = await loadProduct(params.projectId);\n  return (\n    <>\n      <title>{project.name}</title>\n      <ProjectScreen project={project} />\n    </>\n  );\n}\n\nReact Router will no longer bundle this route for the client like it does other routes. The only code that will go to the browser for this route are any rendered \"use client\" modules.\n\nNote that nested routes can be a mix of both server component routes and existing client component routes so that you can use RSC where it makes sense or incrementally adopt it across the app.\nServer Routes + Loaders/Actions\n\nServer Routes can still define loaders and actions.\n\nLoaders run before the React RSC streaming render begins. This makes loaders particularly useful for ensuring you want to handle the request, and if not, send headers and status codes for proper redirects and HTTP semantics. It's also a great place to optimize data loading by preloading any nested data.\n\nimport { redirect, data } from \"react-router\";\n\nexport async function loader({ request, params }) {\n  // redirect if not authenticated\n  let user = await getUser(request.headers.get(\"Cookie\"));\n  if (!user) {\n    throw redirect(\"/login\", { status: 303 });\n  }\n\n  let project = await getProject(params.id);\n\n  // render error boundary if unauthorized\n  let authorized = isAuthorized(user.id, project);\n  if (!authorized) {\n    throw data(\"Unauthorized\", { status: 401 });\n  }\n\n  // avoid a data waterfall by preloading the project's comments\n  // if you know there's a nested <Comments> server component\n  preloadComments(project.id);\n\n  return { project };\n}\n\nexport async function ServerComponent({ loaderData }) {\n  return <ProjectScreen />;\n}\n\nServer Functions\n\nServer functions defined with \"use server\" are also supported.\n\n\"use server\";\n\nexport async function updateFavorite(formData: FormData) {\n  let movieId = formData.get(\"id\");\n  let intent = formData.get(\"intent\");\n  if (intent === \"add\") {\n    await addFavorite(Number(movieId));\n  } else {\n    await removeFavorite(Number(movieId));\n  }\n}\n\nimport { updateFavorite } from \"./action.ts\";\n\nexport async function AddToFavoritesForm({ movieId }: { movieId: number }) {\n  let isFav = await isFavorite(movieId);\n  return (\n    <form action={updateFavorite}>\n      <input type=\"hidden\" name=\"id\" value={movieId} />\n      <input type=\"hidden\" name=\"intent\" value={liked ? \"remove\" : \"add\"} />\n      <AddToFavoritesButton isFav={isFav} />\n    </form>\n  );\n}\n\nNote that after server functions are called, React Router will automatically revalidate the route and update the UI with the new server content. You don't have to mess around with any cache invalidation.\nClient Components\n\nAnd finally, of course client components are supported too.\n\n\"use client\";\nimport { useFormStatus } from \"react-dom\";\n\nexport function AddToFavoritesButton({ isFav }) {\n  let { pending } = useFormStatus();\n\n  return (\n    <button type=\"submit\">\n      {pending\n        ? isFav\n          ? \"Removing...\"\n          : \"Adding...\"\n        : isFav\n          ? \"Remove from favorites\"\n          : \"Add to favorites\"}\n    </button>\n  );\n}\n\nMovie Demo\n\nI built a little demo. Go easy on it, this is all still unstable and hasn't had the UX and design polish I'd like to bring to it yet.\n\n    RSC Movies Live Demo\n    GitHub Source\n\nBatching and Caching\n\nA couple major concerns with the RSC architecture are N+1 queries and over-fetching. Both are very easy to do when components can fetch their own data. We saw it happen in many Hydrogen v1 apps and it tanked performance to unacceptable levels.\n\nHere, check out one of the components in the demo:\n\nimport { Link } from \"react-router\";\nimport { load } from \"../db\";\n\nexport async function ActorLink({ id }: { id: number }) {\n  let actor = await load().actor(id);\n  return (\n    <Link to={`/actor/${actor.id}`} className=\"text-[#1458E1] hover:underline\">\n      {actor.name}\n    </Link>\n  );\n}\n\nThe demo renders dozens if not hundreds of these actor links sometimes. If load().actor(id) was naive, this would result in dozens of queries to the database. Even if these queries were relatively fast it adds up. It would also refetch the same actor multiple times if that actor was in multiple movies being rendered.\n\nTo avoid these issues this demo takes advantage of the \"batching and caching\" pattern developed by the GraphQL team in DataLoader. It uses an alternative library I developed but it's the same concept.\n\nLet's say a page renders 36 ActorLinks and 12 of them are duplicates (same actor in multiple movies). Instead of making 36 queries for each component, they are all deduped and batched into a single query for all 24 actors. Additionally, if more ActorLinks are streamed another batched query will be made except it will both dedupe and reuse any previously fetched actors. Finally, the cache only lasts as long as the request, so there's no need to expire anything.\nMiddleware Makes it Easy\n\nReact Router's middleware feature makes it dead simple to add this kind of strategy to your app. Here's the code for the demo:\n\nimport { batch } from \"@ryanflorence/batch-loader\";\n\n// Async context to load data from anywhere in the app\nlet context = new AsyncLocalStorage<ReturnType<typeof createLoaders>>();\n\n// React Router middleware to provide the context to the app\nexport const dataMiddleware: MiddlewareFunction<Response> = async (_, next) => {\n  // create batchFunctions for just this request\n  let batchFunctions = {\n    movie: batch(batchMovies),\n    actor: batch(batchActors),\n  };\n\n  return new Promise((resolve) => {\n    context.run(batchFunctions, () => {\n      resolve(next());\n    });\n  });\n};\n\n// load function to be used anywhere, especially in components\nexport function load() {\n  return context.getStore() as ReturnType<typeof createLoaders>;\n}\n\nThe middleware is then plugged into the root route:\n\nexport const unstable_middleware = [sessionMiddleware, dataMiddleware];\n\nNow any component (or any other server code) can import load and naively load movies and actors. Here's the MovieTile from the demo.\n\nimport { Link } from \"react-router\";\nimport { load } from \"../db\";\nimport { ActorLink } from \"./actor-link\";\nimport { AddToFavoritesForm } from \"./add-to-favorites/form\";\n\nexport async function MovieTile({ id }: { id: number }) {\n  let movie = await load().movie(id);\n\n  return (\n    <div className=\"flex w-[296px] flex-col gap-y-9\">\n      <Link to={`/movie/${movie.id}`}>\n        <img\n          src={movie.thumbnail}\n          className=\"mb-4 h-[435px] w-full object-cover\"\n          alt={movie.title}\n        />\n      </Link>\n\n      <AddToFavoritesForm movieId={movie.id} />\n\n      <h2 className=\"font-instrumentSerif text-3xl\">\n        <Link to={`/movie/${movie.id}`} className=\"hover:underline\">\n          {movie.title}\n        </Link>{\" \"}\n        ({movie.year})\n      </h2>\n\n      <p className=\"mb-2\">\n        {movie.extract.length > 350\n          ? movie.extract.slice(0, 350) + \"...\"\n          : movie.extract}\n      </p>\n\n      <p>\n        <b className=\"font-semibold\">Starring</b>:{\" \"}\n        {movie.cast_ids.map((id, index, arr) => (\n          <ActorLink id={id} />\n        ))}\n      </p>\n    </div>\n  );\n}\n\nYou can render any number of MovieTiles anywhere, each rendering a bunch of ActorLinks, and only two queries will be made to the DB, even though the component is only asking for one. Pretty cool!\n\nI think this is a pretty critical requirement for the RSC architecture to work and we're looking into making it an official part of React Router.\nEasiest Way to Use All of React is React Router\n\nSomething a little unexpected happened while we were working on this: a lot of code moved from our Vite plugin and \"Framework mode\" to our lower level \"Data mode\" runtime. This makes it significantly easier to bring your own bundler to React Router and use all of React 19's feature set.\n\nWhen Remix was first released (before it made its way into React Router v7), it provided answers to a lot of questions for production React apps, including:\n\n    How do I load code from the server into my React components?\n    How do I change data on the server from React components?\n    How do I pre-render my application to HTML on the server?\n    How do I know which client assets are needed to transition the HTML into a single-page application?\n    How do I get the serialized server data into the components in the browser for it to be interactive?\n\nOur answers were loaders, actions, server runtimes, browser runtimes, and a bundler that connected the server and browser together (hydration) through build manifests and serialized data payloads. We called the whole thing Remix.\n\nWith the release of React 19, React itself now has answers for all of those questions with async components, RSC streaming formats, and bundler integrations. Our job got much smaller!\n\nEven APIs like clientLoader that today rely on our Vite plugin are able to be sent through the RSC format at runtime to work with any bundler that supports RSC.\n\nJacob blew my mind with that one.\n\nWith less reliance on our own Vite plugin, and deeper integration with React, supporting all of React Router's framework features should be much more realistic for bundlers besides Vite.\nWhat's Next? Official RSC Support in Vite\n\nYou'll note that the preview template only supports Parcel. That's because Vite doesn't have RSC support yet. Work is ongoing between the Vite and React teams, and things are looking good. In the meantime, we're leveraging Parcel's RSC support to help us figure out what React Router looks like when RSC is a first-class bundler feature. You'll note in the preview template there's a little Parcel plugin for routes.ts to button it all up and it's pretty small. The effort to port to other RSC-native bundlers in the future should be equally minimal.\n\nBy targeting RSC-native bundlers like Parcel, we're also helping to guide the direction of Vite's official RSC support. Hiroshi Ogawa is currently working publicly on Vite RSC support and using React Router's RSC APIs in Vite to validate their approach. By sharing our early RSC work publicly, we can help ensure that we'll be ready once Vite RSC support finally lands.\n\nThis is very exciting for us: both React's and React Router's full feature sets will soon be usable with very little effort with any bundler, any JavaScript runtime, and any server!\n\nAlso, there's still some work to do around optimizing revalidation. Currently, the entire page is revalidated after server actions. Because server actions aren't tied to a specific route, our current shouldRevalidate approach feels awkward. We're working on a better page revalidation approach that feels great for all use cases.\n\nTake it for a spin and let us know what you think!\n",
  "date": "2026-01-20",
  "image": "http://localhost:5000/uploads/articles/1768939828711-354961324.jpg",
  "author": "Admin"
}